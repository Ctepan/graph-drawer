<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
    <style>
        #c1 {
            width: 500px;
            height: 500px;
            border: 1px solid black;
        }
    </style>
    <canvas id="c1" width="500" height="500"></canvas>
    <script>
        const canvas = document.getElementById('c1');
        const ctx = canvas.getContext('2d');
        const [CTX_HEIGHT, CTX_WIDTH] = [500, 500];

        class Vertex {
            constructor(name, x, y) {
                this.name = name;
                this.x = x;
                this.y = y;
            }
            setCoords(x, y) {
                this.x = x;
                this.y = y;
            }
        }
        class Edge {
            constructor(a, b, value) {
                this.a = a;
                this.b = b;
                this.value = value;
            }
        }
        const graph = {
            canvas: canvas,
            ctx: ctx,
            edges: [],
            vertices: [],
            connections: new Map(),
            drawEdge: function(edge) {
                this.ctx.beginPath();
                this.ctx.moveTo(edge.a.x, edge.a.y);
                this.ctx.lineTo(edge.b.x, edge.b.y);
                this.ctx.closePath();
                this.ctx.stroke();
                this.ctx.fillStyle = 'red';
            },
            drawVertex: function(vertex) {
                ctx.fillStyle = 'black';
                ctx.beginPath();
                ctx.arc(vertex.x, vertex.y, 3, 0, 2 * Math.PI);
                ctx.fill();
                ctx.font = '16px sans-serif';
                ctx.fillText(vertex.name, vertex.x, vertex.y);
            },
            drawEdges: function() {
                this.edges.forEach(x=>{
                    this.drawEdge(x);
                    this.drawVertex(x.a);
                    this.drawVertex(x.b);
                });
            },
            processPairs: function(pairList) {
                const vSet = new Set();
                const eList = [];

                for (let i of pairList) {
                    vSet.add(i[0]);
                    vSet.add(i[1]);
                }
                
                let vMap = new Map();

                for (let i of [...vSet.values()]) {
                    const vObj = new Vertex(i);
                    vMap.set(i, vObj);
                    this.connections.set(vObj, []);
                }

                for (let i of pairList) {
                    const vObj1 = vMap.get(i[0]);
                    const vObj2 = vMap.get(i[1]);
                    this.connections.get(vObj1).push(vObj2);
                    this.connections.get(vObj2).push(vObj1);
                    eList.push(new Edge(vObj1, vObj2, i[2]));
                }
                
                this.vertices = [...this.connections.keys()];
                this.edges = eList;
            }
        }
        
        const pairs = [
            [1,2,0],[1,3,0],[1,4,0],[4,3,0],[0,2,0],[4,2,0],[5,4,0],[0,5,0]
        ]

        graph.processPairs(pairs);

        function takeCoordsToVerticies(vertices) {
            const pi = Math.PI;

            for (const v in vertices) {
                vertices[v].setCoords(
                    CTX_WIDTH / 2 + 50 * Math.cos(2 * pi * v / vertices.length), 
                    CTX_HEIGHT / 2 + 50 * Math.sin(2 * pi * v / vertices.length)
                );
            }
        }

        takeCoordsToVerticies(graph.vertices);
        graph.drawEdges();
    </script>
</body>
</html>